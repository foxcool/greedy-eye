// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/foxcool/greedy-eye/internal/services/storage/ent/account"
	"github.com/foxcool/greedy-eye/internal/services/storage/ent/asset"
	"github.com/foxcool/greedy-eye/internal/services/storage/ent/holding"
	"github.com/foxcool/greedy-eye/internal/services/storage/ent/portfolio"
	"github.com/foxcool/greedy-eye/internal/services/storage/ent/predicate"
	"github.com/foxcool/greedy-eye/internal/services/storage/ent/price"
	"github.com/foxcool/greedy-eye/internal/services/storage/ent/transaction"
	"github.com/foxcool/greedy-eye/internal/services/storage/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount     = "Account"
	TypeAsset       = "Asset"
	TypeHolding     = "Holding"
	TypePortfolio   = "Portfolio"
	TypePrice       = "Price"
	TypeTransaction = "Transaction"
	TypeUser        = "User"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op              Op
	typ             string
	id              *int
	uuid            *uuid.UUID
	name            *string
	description     *string
	_type           *account.Type
	data            *map[string]string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	holdings        map[int]struct{}
	removedholdings map[int]struct{}
	clearedholdings bool
	done            bool
	oldValue        func(context.Context) (*Account, error)
	predicates      []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *AccountMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AccountMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AccountMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AccountMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[account.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AccountMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[account.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, account.FieldDescription)
}

// SetType sets the "type" field.
func (m *AccountMutation) SetType(a account.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountMutation) GetType() (r account.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldType(ctx context.Context) (v account.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AccountMutation) ResetType() {
	m._type = nil
}

// SetData sets the "data" field.
func (m *AccountMutation) SetData(value map[string]string) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *AccountMutation) Data() (r map[string]string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldData(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *AccountMutation) ResetData() {
	m.data = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AccountMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AccountMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AccountMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddHoldingIDs adds the "holdings" edge to the Holding entity by ids.
func (m *AccountMutation) AddHoldingIDs(ids ...int) {
	if m.holdings == nil {
		m.holdings = make(map[int]struct{})
	}
	for i := range ids {
		m.holdings[ids[i]] = struct{}{}
	}
}

// ClearHoldings clears the "holdings" edge to the Holding entity.
func (m *AccountMutation) ClearHoldings() {
	m.clearedholdings = true
}

// HoldingsCleared reports if the "holdings" edge to the Holding entity was cleared.
func (m *AccountMutation) HoldingsCleared() bool {
	return m.clearedholdings
}

// RemoveHoldingIDs removes the "holdings" edge to the Holding entity by IDs.
func (m *AccountMutation) RemoveHoldingIDs(ids ...int) {
	if m.removedholdings == nil {
		m.removedholdings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.holdings, ids[i])
		m.removedholdings[ids[i]] = struct{}{}
	}
}

// RemovedHoldings returns the removed IDs of the "holdings" edge to the Holding entity.
func (m *AccountMutation) RemovedHoldingsIDs() (ids []int) {
	for id := range m.removedholdings {
		ids = append(ids, id)
	}
	return
}

// HoldingsIDs returns the "holdings" edge IDs in the mutation.
func (m *AccountMutation) HoldingsIDs() (ids []int) {
	for id := range m.holdings {
		ids = append(ids, id)
	}
	return
}

// ResetHoldings resets all changes to the "holdings" edge.
func (m *AccountMutation) ResetHoldings() {
	m.holdings = nil
	m.clearedholdings = false
	m.removedholdings = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, account.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.description != nil {
		fields = append(fields, account.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, account.FieldType)
	}
	if m.data != nil {
		fields = append(fields, account.FieldData)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUUID:
		return m.UUID()
	case account.FieldName:
		return m.Name()
	case account.FieldDescription:
		return m.Description()
	case account.FieldType:
		return m.GetType()
	case account.FieldData:
		return m.Data()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldUUID:
		return m.OldUUID(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldDescription:
		return m.OldDescription(ctx)
	case account.FieldType:
		return m.OldType(ctx)
	case account.FieldData:
		return m.OldData(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case account.FieldType:
		v, ok := value.(account.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case account.FieldData:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldDescription) {
		fields = append(fields, account.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldUUID:
		m.ResetUUID()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldDescription:
		m.ResetDescription()
		return nil
	case account.FieldType:
		m.ResetType()
		return nil
	case account.FieldData:
		m.ResetData()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, account.EdgeUser)
	}
	if m.holdings != nil {
		edges = append(edges, account.EdgeHoldings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeHoldings:
		ids := make([]ent.Value, 0, len(m.holdings))
		for id := range m.holdings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedholdings != nil {
		edges = append(edges, account.EdgeHoldings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeHoldings:
		ids := make([]ent.Value, 0, len(m.removedholdings))
		for id := range m.removedholdings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, account.EdgeUser)
	}
	if m.clearedholdings {
		edges = append(edges, account.EdgeHoldings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeUser:
		return m.cleareduser
	case account.EdgeHoldings:
		return m.clearedholdings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeUser:
		m.ResetUser()
		return nil
	case account.EdgeHoldings:
		m.ResetHoldings()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op              Op
	typ             string
	id              *int
	uuid            *uuid.UUID
	symbol          *string
	name            *string
	_type           *asset.Type
	tags            *[]string
	appendtags      []string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	holdings        map[int]struct{}
	removedholdings map[int]struct{}
	clearedholdings bool
	done            bool
	oldValue        func(context.Context) (*Asset, error)
	predicates      []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id int) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *AssetMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AssetMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AssetMutation) ResetUUID() {
	m.uuid = nil
}

// SetSymbol sets the "symbol" field.
func (m *AssetMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *AssetMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *AssetMutation) ResetSymbol() {
	m.symbol = nil
}

// SetName sets the "name" field.
func (m *AssetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AssetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AssetMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AssetMutation) SetType(a asset.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AssetMutation) GetType() (r asset.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldType(ctx context.Context) (v asset.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AssetMutation) ResetType() {
	m._type = nil
}

// SetTags sets the "tags" field.
func (m *AssetMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AssetMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *AssetMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *AssetMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *AssetMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddHoldingIDs adds the "holdings" edge to the Holding entity by ids.
func (m *AssetMutation) AddHoldingIDs(ids ...int) {
	if m.holdings == nil {
		m.holdings = make(map[int]struct{})
	}
	for i := range ids {
		m.holdings[ids[i]] = struct{}{}
	}
}

// ClearHoldings clears the "holdings" edge to the Holding entity.
func (m *AssetMutation) ClearHoldings() {
	m.clearedholdings = true
}

// HoldingsCleared reports if the "holdings" edge to the Holding entity was cleared.
func (m *AssetMutation) HoldingsCleared() bool {
	return m.clearedholdings
}

// RemoveHoldingIDs removes the "holdings" edge to the Holding entity by IDs.
func (m *AssetMutation) RemoveHoldingIDs(ids ...int) {
	if m.removedholdings == nil {
		m.removedholdings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.holdings, ids[i])
		m.removedholdings[ids[i]] = struct{}{}
	}
}

// RemovedHoldings returns the removed IDs of the "holdings" edge to the Holding entity.
func (m *AssetMutation) RemovedHoldingsIDs() (ids []int) {
	for id := range m.removedholdings {
		ids = append(ids, id)
	}
	return
}

// HoldingsIDs returns the "holdings" edge IDs in the mutation.
func (m *AssetMutation) HoldingsIDs() (ids []int) {
	for id := range m.holdings {
		ids = append(ids, id)
	}
	return
}

// ResetHoldings resets all changes to the "holdings" edge.
func (m *AssetMutation) ResetHoldings() {
	m.holdings = nil
	m.clearedholdings = false
	m.removedholdings = nil
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Asset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, asset.FieldUUID)
	}
	if m.symbol != nil {
		fields = append(fields, asset.FieldSymbol)
	}
	if m.name != nil {
		fields = append(fields, asset.FieldName)
	}
	if m._type != nil {
		fields = append(fields, asset.FieldType)
	}
	if m.tags != nil {
		fields = append(fields, asset.FieldTags)
	}
	if m.created_at != nil {
		fields = append(fields, asset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, asset.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldUUID:
		return m.UUID()
	case asset.FieldSymbol:
		return m.Symbol()
	case asset.FieldName:
		return m.Name()
	case asset.FieldType:
		return m.GetType()
	case asset.FieldTags:
		return m.Tags()
	case asset.FieldCreatedAt:
		return m.CreatedAt()
	case asset.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldUUID:
		return m.OldUUID(ctx)
	case asset.FieldSymbol:
		return m.OldSymbol(ctx)
	case asset.FieldName:
		return m.OldName(ctx)
	case asset.FieldType:
		return m.OldType(ctx)
	case asset.FieldTags:
		return m.OldTags(ctx)
	case asset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case asset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case asset.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case asset.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case asset.FieldType:
		v, ok := value.(asset.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case asset.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case asset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case asset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldUUID:
		m.ResetUUID()
		return nil
	case asset.FieldSymbol:
		m.ResetSymbol()
		return nil
	case asset.FieldName:
		m.ResetName()
		return nil
	case asset.FieldType:
		m.ResetType()
		return nil
	case asset.FieldTags:
		m.ResetTags()
		return nil
	case asset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case asset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.holdings != nil {
		edges = append(edges, asset.EdgeHoldings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeHoldings:
		ids := make([]ent.Value, 0, len(m.holdings))
		for id := range m.holdings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedholdings != nil {
		edges = append(edges, asset.EdgeHoldings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeHoldings:
		ids := make([]ent.Value, 0, len(m.removedholdings))
		for id := range m.removedholdings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedholdings {
		edges = append(edges, asset.EdgeHoldings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgeHoldings:
		return m.clearedholdings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgeHoldings:
		m.ResetHoldings()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// HoldingMutation represents an operation that mutates the Holding nodes in the graph.
type HoldingMutation struct {
	config
	op               Op
	typ              string
	id               *int
	uuid             *uuid.UUID
	amount           *int64
	addamount        *int64
	precision        *uint32
	addprecision     *int32
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	asset            *int
	clearedasset     bool
	portfolio        *int
	clearedportfolio bool
	account          *int
	clearedaccount   bool
	done             bool
	oldValue         func(context.Context) (*Holding, error)
	predicates       []predicate.Holding
}

var _ ent.Mutation = (*HoldingMutation)(nil)

// holdingOption allows management of the mutation configuration using functional options.
type holdingOption func(*HoldingMutation)

// newHoldingMutation creates new mutation for the Holding entity.
func newHoldingMutation(c config, op Op, opts ...holdingOption) *HoldingMutation {
	m := &HoldingMutation{
		config:        c,
		op:            op,
		typ:           TypeHolding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHoldingID sets the ID field of the mutation.
func withHoldingID(id int) holdingOption {
	return func(m *HoldingMutation) {
		var (
			err   error
			once  sync.Once
			value *Holding
		)
		m.oldValue = func(ctx context.Context) (*Holding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Holding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHolding sets the old Holding of the mutation.
func withHolding(node *Holding) holdingOption {
	return func(m *HoldingMutation) {
		m.oldValue = func(context.Context) (*Holding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HoldingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HoldingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HoldingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HoldingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Holding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *HoldingMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *HoldingMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Holding entity.
// If the Holding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HoldingMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *HoldingMutation) ResetUUID() {
	m.uuid = nil
}

// SetAmount sets the "amount" field.
func (m *HoldingMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *HoldingMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Holding entity.
// If the Holding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HoldingMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *HoldingMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *HoldingMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *HoldingMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPrecision sets the "precision" field.
func (m *HoldingMutation) SetPrecision(u uint32) {
	m.precision = &u
	m.addprecision = nil
}

// Precision returns the value of the "precision" field in the mutation.
func (m *HoldingMutation) Precision() (r uint32, exists bool) {
	v := m.precision
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecision returns the old "precision" field's value of the Holding entity.
// If the Holding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HoldingMutation) OldPrecision(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecision: %w", err)
	}
	return oldValue.Precision, nil
}

// AddPrecision adds u to the "precision" field.
func (m *HoldingMutation) AddPrecision(u int32) {
	if m.addprecision != nil {
		*m.addprecision += u
	} else {
		m.addprecision = &u
	}
}

// AddedPrecision returns the value that was added to the "precision" field in this mutation.
func (m *HoldingMutation) AddedPrecision() (r int32, exists bool) {
	v := m.addprecision
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrecision resets all changes to the "precision" field.
func (m *HoldingMutation) ResetPrecision() {
	m.precision = nil
	m.addprecision = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HoldingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HoldingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Holding entity.
// If the Holding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HoldingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HoldingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HoldingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HoldingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Holding entity.
// If the Holding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HoldingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HoldingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAssetID sets the "asset" edge to the Asset entity by id.
func (m *HoldingMutation) SetAssetID(id int) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *HoldingMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *HoldingMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *HoldingMutation) AssetID() (id int, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *HoldingMutation) AssetIDs() (ids []int) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *HoldingMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// SetPortfolioID sets the "portfolio" edge to the Portfolio entity by id.
func (m *HoldingMutation) SetPortfolioID(id int) {
	m.portfolio = &id
}

// ClearPortfolio clears the "portfolio" edge to the Portfolio entity.
func (m *HoldingMutation) ClearPortfolio() {
	m.clearedportfolio = true
}

// PortfolioCleared reports if the "portfolio" edge to the Portfolio entity was cleared.
func (m *HoldingMutation) PortfolioCleared() bool {
	return m.clearedportfolio
}

// PortfolioID returns the "portfolio" edge ID in the mutation.
func (m *HoldingMutation) PortfolioID() (id int, exists bool) {
	if m.portfolio != nil {
		return *m.portfolio, true
	}
	return
}

// PortfolioIDs returns the "portfolio" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PortfolioID instead. It exists only for internal usage by the builders.
func (m *HoldingMutation) PortfolioIDs() (ids []int) {
	if id := m.portfolio; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPortfolio resets all changes to the "portfolio" edge.
func (m *HoldingMutation) ResetPortfolio() {
	m.portfolio = nil
	m.clearedportfolio = false
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *HoldingMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *HoldingMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *HoldingMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *HoldingMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *HoldingMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *HoldingMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the HoldingMutation builder.
func (m *HoldingMutation) Where(ps ...predicate.Holding) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HoldingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HoldingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Holding, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HoldingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HoldingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Holding).
func (m *HoldingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HoldingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.uuid != nil {
		fields = append(fields, holding.FieldUUID)
	}
	if m.amount != nil {
		fields = append(fields, holding.FieldAmount)
	}
	if m.precision != nil {
		fields = append(fields, holding.FieldPrecision)
	}
	if m.created_at != nil {
		fields = append(fields, holding.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, holding.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HoldingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case holding.FieldUUID:
		return m.UUID()
	case holding.FieldAmount:
		return m.Amount()
	case holding.FieldPrecision:
		return m.Precision()
	case holding.FieldCreatedAt:
		return m.CreatedAt()
	case holding.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HoldingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case holding.FieldUUID:
		return m.OldUUID(ctx)
	case holding.FieldAmount:
		return m.OldAmount(ctx)
	case holding.FieldPrecision:
		return m.OldPrecision(ctx)
	case holding.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case holding.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Holding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HoldingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case holding.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case holding.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case holding.FieldPrecision:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecision(v)
		return nil
	case holding.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case holding.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Holding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HoldingMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, holding.FieldAmount)
	}
	if m.addprecision != nil {
		fields = append(fields, holding.FieldPrecision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HoldingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case holding.FieldAmount:
		return m.AddedAmount()
	case holding.FieldPrecision:
		return m.AddedPrecision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HoldingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case holding.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case holding.FieldPrecision:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecision(v)
		return nil
	}
	return fmt.Errorf("unknown Holding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HoldingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HoldingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HoldingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Holding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HoldingMutation) ResetField(name string) error {
	switch name {
	case holding.FieldUUID:
		m.ResetUUID()
		return nil
	case holding.FieldAmount:
		m.ResetAmount()
		return nil
	case holding.FieldPrecision:
		m.ResetPrecision()
		return nil
	case holding.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case holding.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Holding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HoldingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.asset != nil {
		edges = append(edges, holding.EdgeAsset)
	}
	if m.portfolio != nil {
		edges = append(edges, holding.EdgePortfolio)
	}
	if m.account != nil {
		edges = append(edges, holding.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HoldingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case holding.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case holding.EdgePortfolio:
		if id := m.portfolio; id != nil {
			return []ent.Value{*id}
		}
	case holding.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HoldingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HoldingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HoldingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedasset {
		edges = append(edges, holding.EdgeAsset)
	}
	if m.clearedportfolio {
		edges = append(edges, holding.EdgePortfolio)
	}
	if m.clearedaccount {
		edges = append(edges, holding.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HoldingMutation) EdgeCleared(name string) bool {
	switch name {
	case holding.EdgeAsset:
		return m.clearedasset
	case holding.EdgePortfolio:
		return m.clearedportfolio
	case holding.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HoldingMutation) ClearEdge(name string) error {
	switch name {
	case holding.EdgeAsset:
		m.ClearAsset()
		return nil
	case holding.EdgePortfolio:
		m.ClearPortfolio()
		return nil
	case holding.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Holding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HoldingMutation) ResetEdge(name string) error {
	switch name {
	case holding.EdgeAsset:
		m.ResetAsset()
		return nil
	case holding.EdgePortfolio:
		m.ResetPortfolio()
		return nil
	case holding.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown Holding edge %s", name)
}

// PortfolioMutation represents an operation that mutates the Portfolio nodes in the graph.
type PortfolioMutation struct {
	config
	op              Op
	typ             string
	id              *int
	uuid            *uuid.UUID
	name            *string
	description     *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	holdings        map[int]struct{}
	removedholdings map[int]struct{}
	clearedholdings bool
	done            bool
	oldValue        func(context.Context) (*Portfolio, error)
	predicates      []predicate.Portfolio
}

var _ ent.Mutation = (*PortfolioMutation)(nil)

// portfolioOption allows management of the mutation configuration using functional options.
type portfolioOption func(*PortfolioMutation)

// newPortfolioMutation creates new mutation for the Portfolio entity.
func newPortfolioMutation(c config, op Op, opts ...portfolioOption) *PortfolioMutation {
	m := &PortfolioMutation{
		config:        c,
		op:            op,
		typ:           TypePortfolio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortfolioID sets the ID field of the mutation.
func withPortfolioID(id int) portfolioOption {
	return func(m *PortfolioMutation) {
		var (
			err   error
			once  sync.Once
			value *Portfolio
		)
		m.oldValue = func(ctx context.Context) (*Portfolio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Portfolio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortfolio sets the old Portfolio of the mutation.
func withPortfolio(node *Portfolio) portfolioOption {
	return func(m *PortfolioMutation) {
		m.oldValue = func(context.Context) (*Portfolio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortfolioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortfolioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortfolioMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortfolioMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Portfolio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *PortfolioMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *PortfolioMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *PortfolioMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *PortfolioMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PortfolioMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PortfolioMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PortfolioMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PortfolioMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PortfolioMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[portfolio.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PortfolioMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PortfolioMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, portfolio.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *PortfolioMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PortfolioMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PortfolioMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PortfolioMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PortfolioMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PortfolioMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PortfolioMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PortfolioMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PortfolioMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PortfolioMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PortfolioMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PortfolioMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddHoldingIDs adds the "holdings" edge to the Holding entity by ids.
func (m *PortfolioMutation) AddHoldingIDs(ids ...int) {
	if m.holdings == nil {
		m.holdings = make(map[int]struct{})
	}
	for i := range ids {
		m.holdings[ids[i]] = struct{}{}
	}
}

// ClearHoldings clears the "holdings" edge to the Holding entity.
func (m *PortfolioMutation) ClearHoldings() {
	m.clearedholdings = true
}

// HoldingsCleared reports if the "holdings" edge to the Holding entity was cleared.
func (m *PortfolioMutation) HoldingsCleared() bool {
	return m.clearedholdings
}

// RemoveHoldingIDs removes the "holdings" edge to the Holding entity by IDs.
func (m *PortfolioMutation) RemoveHoldingIDs(ids ...int) {
	if m.removedholdings == nil {
		m.removedholdings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.holdings, ids[i])
		m.removedholdings[ids[i]] = struct{}{}
	}
}

// RemovedHoldings returns the removed IDs of the "holdings" edge to the Holding entity.
func (m *PortfolioMutation) RemovedHoldingsIDs() (ids []int) {
	for id := range m.removedholdings {
		ids = append(ids, id)
	}
	return
}

// HoldingsIDs returns the "holdings" edge IDs in the mutation.
func (m *PortfolioMutation) HoldingsIDs() (ids []int) {
	for id := range m.holdings {
		ids = append(ids, id)
	}
	return
}

// ResetHoldings resets all changes to the "holdings" edge.
func (m *PortfolioMutation) ResetHoldings() {
	m.holdings = nil
	m.clearedholdings = false
	m.removedholdings = nil
}

// Where appends a list predicates to the PortfolioMutation builder.
func (m *PortfolioMutation) Where(ps ...predicate.Portfolio) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PortfolioMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PortfolioMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Portfolio, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PortfolioMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PortfolioMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Portfolio).
func (m *PortfolioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortfolioMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.uuid != nil {
		fields = append(fields, portfolio.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, portfolio.FieldName)
	}
	if m.description != nil {
		fields = append(fields, portfolio.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, portfolio.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, portfolio.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortfolioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portfolio.FieldUUID:
		return m.UUID()
	case portfolio.FieldName:
		return m.Name()
	case portfolio.FieldDescription:
		return m.Description()
	case portfolio.FieldCreatedAt:
		return m.CreatedAt()
	case portfolio.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortfolioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portfolio.FieldUUID:
		return m.OldUUID(ctx)
	case portfolio.FieldName:
		return m.OldName(ctx)
	case portfolio.FieldDescription:
		return m.OldDescription(ctx)
	case portfolio.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case portfolio.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Portfolio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portfolio.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case portfolio.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case portfolio.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case portfolio.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case portfolio.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortfolioMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortfolioMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Portfolio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortfolioMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(portfolio.FieldDescription) {
		fields = append(fields, portfolio.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortfolioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortfolioMutation) ClearField(name string) error {
	switch name {
	case portfolio.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Portfolio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortfolioMutation) ResetField(name string) error {
	switch name {
	case portfolio.FieldUUID:
		m.ResetUUID()
		return nil
	case portfolio.FieldName:
		m.ResetName()
		return nil
	case portfolio.FieldDescription:
		m.ResetDescription()
		return nil
	case portfolio.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case portfolio.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortfolioMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, portfolio.EdgeUser)
	}
	if m.holdings != nil {
		edges = append(edges, portfolio.EdgeHoldings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortfolioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case portfolio.EdgeHoldings:
		ids := make([]ent.Value, 0, len(m.holdings))
		for id := range m.holdings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortfolioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedholdings != nil {
		edges = append(edges, portfolio.EdgeHoldings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortfolioMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeHoldings:
		ids := make([]ent.Value, 0, len(m.removedholdings))
		for id := range m.removedholdings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortfolioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, portfolio.EdgeUser)
	}
	if m.clearedholdings {
		edges = append(edges, portfolio.EdgeHoldings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortfolioMutation) EdgeCleared(name string) bool {
	switch name {
	case portfolio.EdgeUser:
		return m.cleareduser
	case portfolio.EdgeHoldings:
		return m.clearedholdings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortfolioMutation) ClearEdge(name string) error {
	switch name {
	case portfolio.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Portfolio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortfolioMutation) ResetEdge(name string) error {
	switch name {
	case portfolio.EdgeUser:
		m.ResetUser()
		return nil
	case portfolio.EdgeHoldings:
		m.ResetHoldings()
		return nil
	}
	return fmt.Errorf("unknown Portfolio edge %s", name)
}

// PriceMutation represents an operation that mutates the Price nodes in the graph.
type PriceMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *uuid.UUID
	source_id         *string
	interval          *string
	amount            *int64
	addamount         *int64
	precision         *uint32
	addprecision      *int32
	open              *int64
	addopen           *int64
	high              *int64
	addhigh           *int64
	low               *int64
	addlow            *int64
	close             *int64
	addclose          *int64
	volume            *int64
	addvolume         *int64
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	asset             map[int]struct{}
	removedasset      map[int]struct{}
	clearedasset      bool
	base_asset        map[int]struct{}
	removedbase_asset map[int]struct{}
	clearedbase_asset bool
	done              bool
	oldValue          func(context.Context) (*Price, error)
	predicates        []predicate.Price
}

var _ ent.Mutation = (*PriceMutation)(nil)

// priceOption allows management of the mutation configuration using functional options.
type priceOption func(*PriceMutation)

// newPriceMutation creates new mutation for the Price entity.
func newPriceMutation(c config, op Op, opts ...priceOption) *PriceMutation {
	m := &PriceMutation{
		config:        c,
		op:            op,
		typ:           TypePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPriceID sets the ID field of the mutation.
func withPriceID(id int) priceOption {
	return func(m *PriceMutation) {
		var (
			err   error
			once  sync.Once
			value *Price
		)
		m.oldValue = func(ctx context.Context) (*Price, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Price.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrice sets the old Price of the mutation.
func withPrice(node *Price) priceOption {
	return func(m *PriceMutation) {
		m.oldValue = func(context.Context) (*Price, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PriceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PriceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Price.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *PriceMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *PriceMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *PriceMutation) ResetUUID() {
	m.uuid = nil
}

// SetSourceID sets the "source_id" field.
func (m *PriceMutation) SetSourceID(s string) {
	m.source_id = &s
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *PriceMutation) SourceID() (r string, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldSourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *PriceMutation) ResetSourceID() {
	m.source_id = nil
}

// SetInterval sets the "interval" field.
func (m *PriceMutation) SetInterval(s string) {
	m.interval = &s
}

// Interval returns the value of the "interval" field in the mutation.
func (m *PriceMutation) Interval() (r string, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInterval returns the old "interval" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterval: %w", err)
	}
	return oldValue.Interval, nil
}

// ResetInterval resets all changes to the "interval" field.
func (m *PriceMutation) ResetInterval() {
	m.interval = nil
}

// SetAmount sets the "amount" field.
func (m *PriceMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PriceMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *PriceMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PriceMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PriceMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPrecision sets the "precision" field.
func (m *PriceMutation) SetPrecision(u uint32) {
	m.precision = &u
	m.addprecision = nil
}

// Precision returns the value of the "precision" field in the mutation.
func (m *PriceMutation) Precision() (r uint32, exists bool) {
	v := m.precision
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecision returns the old "precision" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldPrecision(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecision: %w", err)
	}
	return oldValue.Precision, nil
}

// AddPrecision adds u to the "precision" field.
func (m *PriceMutation) AddPrecision(u int32) {
	if m.addprecision != nil {
		*m.addprecision += u
	} else {
		m.addprecision = &u
	}
}

// AddedPrecision returns the value that was added to the "precision" field in this mutation.
func (m *PriceMutation) AddedPrecision() (r int32, exists bool) {
	v := m.addprecision
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrecision resets all changes to the "precision" field.
func (m *PriceMutation) ResetPrecision() {
	m.precision = nil
	m.addprecision = nil
}

// SetOpen sets the "open" field.
func (m *PriceMutation) SetOpen(i int64) {
	m.open = &i
	m.addopen = nil
}

// Open returns the value of the "open" field in the mutation.
func (m *PriceMutation) Open() (r int64, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldOpen(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// AddOpen adds i to the "open" field.
func (m *PriceMutation) AddOpen(i int64) {
	if m.addopen != nil {
		*m.addopen += i
	} else {
		m.addopen = &i
	}
}

// AddedOpen returns the value that was added to the "open" field in this mutation.
func (m *PriceMutation) AddedOpen() (r int64, exists bool) {
	v := m.addopen
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpen clears the value of the "open" field.
func (m *PriceMutation) ClearOpen() {
	m.open = nil
	m.addopen = nil
	m.clearedFields[price.FieldOpen] = struct{}{}
}

// OpenCleared returns if the "open" field was cleared in this mutation.
func (m *PriceMutation) OpenCleared() bool {
	_, ok := m.clearedFields[price.FieldOpen]
	return ok
}

// ResetOpen resets all changes to the "open" field.
func (m *PriceMutation) ResetOpen() {
	m.open = nil
	m.addopen = nil
	delete(m.clearedFields, price.FieldOpen)
}

// SetHigh sets the "high" field.
func (m *PriceMutation) SetHigh(i int64) {
	m.high = &i
	m.addhigh = nil
}

// High returns the value of the "high" field in the mutation.
func (m *PriceMutation) High() (r int64, exists bool) {
	v := m.high
	if v == nil {
		return
	}
	return *v, true
}

// OldHigh returns the old "high" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldHigh(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHigh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHigh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHigh: %w", err)
	}
	return oldValue.High, nil
}

// AddHigh adds i to the "high" field.
func (m *PriceMutation) AddHigh(i int64) {
	if m.addhigh != nil {
		*m.addhigh += i
	} else {
		m.addhigh = &i
	}
}

// AddedHigh returns the value that was added to the "high" field in this mutation.
func (m *PriceMutation) AddedHigh() (r int64, exists bool) {
	v := m.addhigh
	if v == nil {
		return
	}
	return *v, true
}

// ClearHigh clears the value of the "high" field.
func (m *PriceMutation) ClearHigh() {
	m.high = nil
	m.addhigh = nil
	m.clearedFields[price.FieldHigh] = struct{}{}
}

// HighCleared returns if the "high" field was cleared in this mutation.
func (m *PriceMutation) HighCleared() bool {
	_, ok := m.clearedFields[price.FieldHigh]
	return ok
}

// ResetHigh resets all changes to the "high" field.
func (m *PriceMutation) ResetHigh() {
	m.high = nil
	m.addhigh = nil
	delete(m.clearedFields, price.FieldHigh)
}

// SetLow sets the "low" field.
func (m *PriceMutation) SetLow(i int64) {
	m.low = &i
	m.addlow = nil
}

// Low returns the value of the "low" field in the mutation.
func (m *PriceMutation) Low() (r int64, exists bool) {
	v := m.low
	if v == nil {
		return
	}
	return *v, true
}

// OldLow returns the old "low" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldLow(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLow: %w", err)
	}
	return oldValue.Low, nil
}

// AddLow adds i to the "low" field.
func (m *PriceMutation) AddLow(i int64) {
	if m.addlow != nil {
		*m.addlow += i
	} else {
		m.addlow = &i
	}
}

// AddedLow returns the value that was added to the "low" field in this mutation.
func (m *PriceMutation) AddedLow() (r int64, exists bool) {
	v := m.addlow
	if v == nil {
		return
	}
	return *v, true
}

// ClearLow clears the value of the "low" field.
func (m *PriceMutation) ClearLow() {
	m.low = nil
	m.addlow = nil
	m.clearedFields[price.FieldLow] = struct{}{}
}

// LowCleared returns if the "low" field was cleared in this mutation.
func (m *PriceMutation) LowCleared() bool {
	_, ok := m.clearedFields[price.FieldLow]
	return ok
}

// ResetLow resets all changes to the "low" field.
func (m *PriceMutation) ResetLow() {
	m.low = nil
	m.addlow = nil
	delete(m.clearedFields, price.FieldLow)
}

// SetClose sets the "close" field.
func (m *PriceMutation) SetClose(i int64) {
	m.close = &i
	m.addclose = nil
}

// Close returns the value of the "close" field in the mutation.
func (m *PriceMutation) Close() (r int64, exists bool) {
	v := m.close
	if v == nil {
		return
	}
	return *v, true
}

// OldClose returns the old "close" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldClose(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClose: %w", err)
	}
	return oldValue.Close, nil
}

// AddClose adds i to the "close" field.
func (m *PriceMutation) AddClose(i int64) {
	if m.addclose != nil {
		*m.addclose += i
	} else {
		m.addclose = &i
	}
}

// AddedClose returns the value that was added to the "close" field in this mutation.
func (m *PriceMutation) AddedClose() (r int64, exists bool) {
	v := m.addclose
	if v == nil {
		return
	}
	return *v, true
}

// ClearClose clears the value of the "close" field.
func (m *PriceMutation) ClearClose() {
	m.close = nil
	m.addclose = nil
	m.clearedFields[price.FieldClose] = struct{}{}
}

// CloseCleared returns if the "close" field was cleared in this mutation.
func (m *PriceMutation) CloseCleared() bool {
	_, ok := m.clearedFields[price.FieldClose]
	return ok
}

// ResetClose resets all changes to the "close" field.
func (m *PriceMutation) ResetClose() {
	m.close = nil
	m.addclose = nil
	delete(m.clearedFields, price.FieldClose)
}

// SetVolume sets the "volume" field.
func (m *PriceMutation) SetVolume(i int64) {
	m.volume = &i
	m.addvolume = nil
}

// Volume returns the value of the "volume" field in the mutation.
func (m *PriceMutation) Volume() (r int64, exists bool) {
	v := m.volume
	if v == nil {
		return
	}
	return *v, true
}

// OldVolume returns the old "volume" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldVolume(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolume: %w", err)
	}
	return oldValue.Volume, nil
}

// AddVolume adds i to the "volume" field.
func (m *PriceMutation) AddVolume(i int64) {
	if m.addvolume != nil {
		*m.addvolume += i
	} else {
		m.addvolume = &i
	}
}

// AddedVolume returns the value that was added to the "volume" field in this mutation.
func (m *PriceMutation) AddedVolume() (r int64, exists bool) {
	v := m.addvolume
	if v == nil {
		return
	}
	return *v, true
}

// ClearVolume clears the value of the "volume" field.
func (m *PriceMutation) ClearVolume() {
	m.volume = nil
	m.addvolume = nil
	m.clearedFields[price.FieldVolume] = struct{}{}
}

// VolumeCleared returns if the "volume" field was cleared in this mutation.
func (m *PriceMutation) VolumeCleared() bool {
	_, ok := m.clearedFields[price.FieldVolume]
	return ok
}

// ResetVolume resets all changes to the "volume" field.
func (m *PriceMutation) ResetVolume() {
	m.volume = nil
	m.addvolume = nil
	delete(m.clearedFields, price.FieldVolume)
}

// SetCreatedAt sets the "created_at" field.
func (m *PriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAssetIDs adds the "asset" edge to the Asset entity by ids.
func (m *PriceMutation) AddAssetIDs(ids ...int) {
	if m.asset == nil {
		m.asset = make(map[int]struct{})
	}
	for i := range ids {
		m.asset[ids[i]] = struct{}{}
	}
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *PriceMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *PriceMutation) AssetCleared() bool {
	return m.clearedasset
}

// RemoveAssetIDs removes the "asset" edge to the Asset entity by IDs.
func (m *PriceMutation) RemoveAssetIDs(ids ...int) {
	if m.removedasset == nil {
		m.removedasset = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.asset, ids[i])
		m.removedasset[ids[i]] = struct{}{}
	}
}

// RemovedAsset returns the removed IDs of the "asset" edge to the Asset entity.
func (m *PriceMutation) RemovedAssetIDs() (ids []int) {
	for id := range m.removedasset {
		ids = append(ids, id)
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
func (m *PriceMutation) AssetIDs() (ids []int) {
	for id := range m.asset {
		ids = append(ids, id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *PriceMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
	m.removedasset = nil
}

// AddBaseAssetIDs adds the "base_asset" edge to the Asset entity by ids.
func (m *PriceMutation) AddBaseAssetIDs(ids ...int) {
	if m.base_asset == nil {
		m.base_asset = make(map[int]struct{})
	}
	for i := range ids {
		m.base_asset[ids[i]] = struct{}{}
	}
}

// ClearBaseAsset clears the "base_asset" edge to the Asset entity.
func (m *PriceMutation) ClearBaseAsset() {
	m.clearedbase_asset = true
}

// BaseAssetCleared reports if the "base_asset" edge to the Asset entity was cleared.
func (m *PriceMutation) BaseAssetCleared() bool {
	return m.clearedbase_asset
}

// RemoveBaseAssetIDs removes the "base_asset" edge to the Asset entity by IDs.
func (m *PriceMutation) RemoveBaseAssetIDs(ids ...int) {
	if m.removedbase_asset == nil {
		m.removedbase_asset = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.base_asset, ids[i])
		m.removedbase_asset[ids[i]] = struct{}{}
	}
}

// RemovedBaseAsset returns the removed IDs of the "base_asset" edge to the Asset entity.
func (m *PriceMutation) RemovedBaseAssetIDs() (ids []int) {
	for id := range m.removedbase_asset {
		ids = append(ids, id)
	}
	return
}

// BaseAssetIDs returns the "base_asset" edge IDs in the mutation.
func (m *PriceMutation) BaseAssetIDs() (ids []int) {
	for id := range m.base_asset {
		ids = append(ids, id)
	}
	return
}

// ResetBaseAsset resets all changes to the "base_asset" edge.
func (m *PriceMutation) ResetBaseAsset() {
	m.base_asset = nil
	m.clearedbase_asset = false
	m.removedbase_asset = nil
}

// Where appends a list predicates to the PriceMutation builder.
func (m *PriceMutation) Where(ps ...predicate.Price) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Price, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Price).
func (m *PriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PriceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.uuid != nil {
		fields = append(fields, price.FieldUUID)
	}
	if m.source_id != nil {
		fields = append(fields, price.FieldSourceID)
	}
	if m.interval != nil {
		fields = append(fields, price.FieldInterval)
	}
	if m.amount != nil {
		fields = append(fields, price.FieldAmount)
	}
	if m.precision != nil {
		fields = append(fields, price.FieldPrecision)
	}
	if m.open != nil {
		fields = append(fields, price.FieldOpen)
	}
	if m.high != nil {
		fields = append(fields, price.FieldHigh)
	}
	if m.low != nil {
		fields = append(fields, price.FieldLow)
	}
	if m.close != nil {
		fields = append(fields, price.FieldClose)
	}
	if m.volume != nil {
		fields = append(fields, price.FieldVolume)
	}
	if m.created_at != nil {
		fields = append(fields, price.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, price.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case price.FieldUUID:
		return m.UUID()
	case price.FieldSourceID:
		return m.SourceID()
	case price.FieldInterval:
		return m.Interval()
	case price.FieldAmount:
		return m.Amount()
	case price.FieldPrecision:
		return m.Precision()
	case price.FieldOpen:
		return m.Open()
	case price.FieldHigh:
		return m.High()
	case price.FieldLow:
		return m.Low()
	case price.FieldClose:
		return m.Close()
	case price.FieldVolume:
		return m.Volume()
	case price.FieldCreatedAt:
		return m.CreatedAt()
	case price.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case price.FieldUUID:
		return m.OldUUID(ctx)
	case price.FieldSourceID:
		return m.OldSourceID(ctx)
	case price.FieldInterval:
		return m.OldInterval(ctx)
	case price.FieldAmount:
		return m.OldAmount(ctx)
	case price.FieldPrecision:
		return m.OldPrecision(ctx)
	case price.FieldOpen:
		return m.OldOpen(ctx)
	case price.FieldHigh:
		return m.OldHigh(ctx)
	case price.FieldLow:
		return m.OldLow(ctx)
	case price.FieldClose:
		return m.OldClose(ctx)
	case price.FieldVolume:
		return m.OldVolume(ctx)
	case price.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case price.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Price field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case price.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case price.FieldSourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case price.FieldInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterval(v)
		return nil
	case price.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case price.FieldPrecision:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecision(v)
		return nil
	case price.FieldOpen:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case price.FieldHigh:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHigh(v)
		return nil
	case price.FieldLow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLow(v)
		return nil
	case price.FieldClose:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClose(v)
		return nil
	case price.FieldVolume:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolume(v)
		return nil
	case price.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case price.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PriceMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, price.FieldAmount)
	}
	if m.addprecision != nil {
		fields = append(fields, price.FieldPrecision)
	}
	if m.addopen != nil {
		fields = append(fields, price.FieldOpen)
	}
	if m.addhigh != nil {
		fields = append(fields, price.FieldHigh)
	}
	if m.addlow != nil {
		fields = append(fields, price.FieldLow)
	}
	if m.addclose != nil {
		fields = append(fields, price.FieldClose)
	}
	if m.addvolume != nil {
		fields = append(fields, price.FieldVolume)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case price.FieldAmount:
		return m.AddedAmount()
	case price.FieldPrecision:
		return m.AddedPrecision()
	case price.FieldOpen:
		return m.AddedOpen()
	case price.FieldHigh:
		return m.AddedHigh()
	case price.FieldLow:
		return m.AddedLow()
	case price.FieldClose:
		return m.AddedClose()
	case price.FieldVolume:
		return m.AddedVolume()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case price.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case price.FieldPrecision:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecision(v)
		return nil
	case price.FieldOpen:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpen(v)
		return nil
	case price.FieldHigh:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHigh(v)
		return nil
	case price.FieldLow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLow(v)
		return nil
	case price.FieldClose:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClose(v)
		return nil
	case price.FieldVolume:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolume(v)
		return nil
	}
	return fmt.Errorf("unknown Price numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(price.FieldOpen) {
		fields = append(fields, price.FieldOpen)
	}
	if m.FieldCleared(price.FieldHigh) {
		fields = append(fields, price.FieldHigh)
	}
	if m.FieldCleared(price.FieldLow) {
		fields = append(fields, price.FieldLow)
	}
	if m.FieldCleared(price.FieldClose) {
		fields = append(fields, price.FieldClose)
	}
	if m.FieldCleared(price.FieldVolume) {
		fields = append(fields, price.FieldVolume)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PriceMutation) ClearField(name string) error {
	switch name {
	case price.FieldOpen:
		m.ClearOpen()
		return nil
	case price.FieldHigh:
		m.ClearHigh()
		return nil
	case price.FieldLow:
		m.ClearLow()
		return nil
	case price.FieldClose:
		m.ClearClose()
		return nil
	case price.FieldVolume:
		m.ClearVolume()
		return nil
	}
	return fmt.Errorf("unknown Price nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PriceMutation) ResetField(name string) error {
	switch name {
	case price.FieldUUID:
		m.ResetUUID()
		return nil
	case price.FieldSourceID:
		m.ResetSourceID()
		return nil
	case price.FieldInterval:
		m.ResetInterval()
		return nil
	case price.FieldAmount:
		m.ResetAmount()
		return nil
	case price.FieldPrecision:
		m.ResetPrecision()
		return nil
	case price.FieldOpen:
		m.ResetOpen()
		return nil
	case price.FieldHigh:
		m.ResetHigh()
		return nil
	case price.FieldLow:
		m.ResetLow()
		return nil
	case price.FieldClose:
		m.ResetClose()
		return nil
	case price.FieldVolume:
		m.ResetVolume()
		return nil
	case price.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case price.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.asset != nil {
		edges = append(edges, price.EdgeAsset)
	}
	if m.base_asset != nil {
		edges = append(edges, price.EdgeBaseAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case price.EdgeAsset:
		ids := make([]ent.Value, 0, len(m.asset))
		for id := range m.asset {
			ids = append(ids, id)
		}
		return ids
	case price.EdgeBaseAsset:
		ids := make([]ent.Value, 0, len(m.base_asset))
		for id := range m.base_asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedasset != nil {
		edges = append(edges, price.EdgeAsset)
	}
	if m.removedbase_asset != nil {
		edges = append(edges, price.EdgeBaseAsset)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PriceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case price.EdgeAsset:
		ids := make([]ent.Value, 0, len(m.removedasset))
		for id := range m.removedasset {
			ids = append(ids, id)
		}
		return ids
	case price.EdgeBaseAsset:
		ids := make([]ent.Value, 0, len(m.removedbase_asset))
		for id := range m.removedbase_asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedasset {
		edges = append(edges, price.EdgeAsset)
	}
	if m.clearedbase_asset {
		edges = append(edges, price.EdgeBaseAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PriceMutation) EdgeCleared(name string) bool {
	switch name {
	case price.EdgeAsset:
		return m.clearedasset
	case price.EdgeBaseAsset:
		return m.clearedbase_asset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PriceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Price unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PriceMutation) ResetEdge(name string) error {
	switch name {
	case price.EdgeAsset:
		m.ResetAsset()
		return nil
	case price.EdgeBaseAsset:
		m.ResetBaseAsset()
		return nil
	}
	return fmt.Errorf("unknown Price edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	uuid             *uuid.UUID
	amount           *int64
	addamount        *int64
	fee              *int64
	addfee           *int64
	precision        *uint32
	addprecision     *int32
	_type            *transaction.Type
	status           *transaction.Status
	created_at       *time.Time
	updated_at       *time.Time
	metadata         *map[string]string
	clearedFields    map[string]struct{}
	portfolio        map[int]struct{}
	removedportfolio map[int]struct{}
	clearedportfolio bool
	account          map[int]struct{}
	removedaccount   map[int]struct{}
	clearedaccount   bool
	asset            map[int]struct{}
	removedasset     map[int]struct{}
	clearedasset     bool
	fee_asset        map[int]struct{}
	removedfee_asset map[int]struct{}
	clearedfee_asset bool
	done             bool
	oldValue         func(context.Context) (*Transaction, error)
	predicates       []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *TransactionMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TransactionMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TransactionMutation) ResetUUID() {
	m.uuid = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TransactionMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetFee sets the "fee" field.
func (m *TransactionMutation) SetFee(i int64) {
	m.fee = &i
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *TransactionMutation) Fee() (r int64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds i to the "fee" field.
func (m *TransactionMutation) AddFee(i int64) {
	if m.addfee != nil {
		*m.addfee += i
	} else {
		m.addfee = &i
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *TransactionMutation) AddedFee() (r int64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFee resets all changes to the "fee" field.
func (m *TransactionMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
}

// SetPrecision sets the "precision" field.
func (m *TransactionMutation) SetPrecision(u uint32) {
	m.precision = &u
	m.addprecision = nil
}

// Precision returns the value of the "precision" field in the mutation.
func (m *TransactionMutation) Precision() (r uint32, exists bool) {
	v := m.precision
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecision returns the old "precision" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPrecision(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecision: %w", err)
	}
	return oldValue.Precision, nil
}

// AddPrecision adds u to the "precision" field.
func (m *TransactionMutation) AddPrecision(u int32) {
	if m.addprecision != nil {
		*m.addprecision += u
	} else {
		m.addprecision = &u
	}
}

// AddedPrecision returns the value that was added to the "precision" field in this mutation.
func (m *TransactionMutation) AddedPrecision() (r int32, exists bool) {
	v := m.addprecision
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrecision resets all changes to the "precision" field.
func (m *TransactionMutation) ResetPrecision() {
	m.precision = nil
	m.addprecision = nil
}

// SetType sets the "type" field.
func (m *TransactionMutation) SetType(t transaction.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransactionMutation) GetType() (r transaction.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldType(ctx context.Context) (v transaction.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransactionMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *TransactionMutation) SetStatus(t transaction.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TransactionMutation) Status() (r transaction.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldStatus(ctx context.Context) (v transaction.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransactionMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMetadata sets the "metadata" field.
func (m *TransactionMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TransactionMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TransactionMutation) ResetMetadata() {
	m.metadata = nil
}

// AddPortfolioIDs adds the "portfolio" edge to the Portfolio entity by ids.
func (m *TransactionMutation) AddPortfolioIDs(ids ...int) {
	if m.portfolio == nil {
		m.portfolio = make(map[int]struct{})
	}
	for i := range ids {
		m.portfolio[ids[i]] = struct{}{}
	}
}

// ClearPortfolio clears the "portfolio" edge to the Portfolio entity.
func (m *TransactionMutation) ClearPortfolio() {
	m.clearedportfolio = true
}

// PortfolioCleared reports if the "portfolio" edge to the Portfolio entity was cleared.
func (m *TransactionMutation) PortfolioCleared() bool {
	return m.clearedportfolio
}

// RemovePortfolioIDs removes the "portfolio" edge to the Portfolio entity by IDs.
func (m *TransactionMutation) RemovePortfolioIDs(ids ...int) {
	if m.removedportfolio == nil {
		m.removedportfolio = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.portfolio, ids[i])
		m.removedportfolio[ids[i]] = struct{}{}
	}
}

// RemovedPortfolio returns the removed IDs of the "portfolio" edge to the Portfolio entity.
func (m *TransactionMutation) RemovedPortfolioIDs() (ids []int) {
	for id := range m.removedportfolio {
		ids = append(ids, id)
	}
	return
}

// PortfolioIDs returns the "portfolio" edge IDs in the mutation.
func (m *TransactionMutation) PortfolioIDs() (ids []int) {
	for id := range m.portfolio {
		ids = append(ids, id)
	}
	return
}

// ResetPortfolio resets all changes to the "portfolio" edge.
func (m *TransactionMutation) ResetPortfolio() {
	m.portfolio = nil
	m.clearedportfolio = false
	m.removedportfolio = nil
}

// AddAccountIDs adds the "account" edge to the Account entity by ids.
func (m *TransactionMutation) AddAccountIDs(ids ...int) {
	if m.account == nil {
		m.account = make(map[int]struct{})
	}
	for i := range ids {
		m.account[ids[i]] = struct{}{}
	}
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *TransactionMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *TransactionMutation) AccountCleared() bool {
	return m.clearedaccount
}

// RemoveAccountIDs removes the "account" edge to the Account entity by IDs.
func (m *TransactionMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccount == nil {
		m.removedaccount = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.account, ids[i])
		m.removedaccount[ids[i]] = struct{}{}
	}
}

// RemovedAccount returns the removed IDs of the "account" edge to the Account entity.
func (m *TransactionMutation) RemovedAccountIDs() (ids []int) {
	for id := range m.removedaccount {
		ids = append(ids, id)
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
func (m *TransactionMutation) AccountIDs() (ids []int) {
	for id := range m.account {
		ids = append(ids, id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *TransactionMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
	m.removedaccount = nil
}

// AddAssetIDs adds the "asset" edge to the Asset entity by ids.
func (m *TransactionMutation) AddAssetIDs(ids ...int) {
	if m.asset == nil {
		m.asset = make(map[int]struct{})
	}
	for i := range ids {
		m.asset[ids[i]] = struct{}{}
	}
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *TransactionMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *TransactionMutation) AssetCleared() bool {
	return m.clearedasset
}

// RemoveAssetIDs removes the "asset" edge to the Asset entity by IDs.
func (m *TransactionMutation) RemoveAssetIDs(ids ...int) {
	if m.removedasset == nil {
		m.removedasset = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.asset, ids[i])
		m.removedasset[ids[i]] = struct{}{}
	}
}

// RemovedAsset returns the removed IDs of the "asset" edge to the Asset entity.
func (m *TransactionMutation) RemovedAssetIDs() (ids []int) {
	for id := range m.removedasset {
		ids = append(ids, id)
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
func (m *TransactionMutation) AssetIDs() (ids []int) {
	for id := range m.asset {
		ids = append(ids, id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *TransactionMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
	m.removedasset = nil
}

// AddFeeAssetIDs adds the "fee_asset" edge to the Asset entity by ids.
func (m *TransactionMutation) AddFeeAssetIDs(ids ...int) {
	if m.fee_asset == nil {
		m.fee_asset = make(map[int]struct{})
	}
	for i := range ids {
		m.fee_asset[ids[i]] = struct{}{}
	}
}

// ClearFeeAsset clears the "fee_asset" edge to the Asset entity.
func (m *TransactionMutation) ClearFeeAsset() {
	m.clearedfee_asset = true
}

// FeeAssetCleared reports if the "fee_asset" edge to the Asset entity was cleared.
func (m *TransactionMutation) FeeAssetCleared() bool {
	return m.clearedfee_asset
}

// RemoveFeeAssetIDs removes the "fee_asset" edge to the Asset entity by IDs.
func (m *TransactionMutation) RemoveFeeAssetIDs(ids ...int) {
	if m.removedfee_asset == nil {
		m.removedfee_asset = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fee_asset, ids[i])
		m.removedfee_asset[ids[i]] = struct{}{}
	}
}

// RemovedFeeAsset returns the removed IDs of the "fee_asset" edge to the Asset entity.
func (m *TransactionMutation) RemovedFeeAssetIDs() (ids []int) {
	for id := range m.removedfee_asset {
		ids = append(ids, id)
	}
	return
}

// FeeAssetIDs returns the "fee_asset" edge IDs in the mutation.
func (m *TransactionMutation) FeeAssetIDs() (ids []int) {
	for id := range m.fee_asset {
		ids = append(ids, id)
	}
	return
}

// ResetFeeAsset resets all changes to the "fee_asset" edge.
func (m *TransactionMutation) ResetFeeAsset() {
	m.fee_asset = nil
	m.clearedfee_asset = false
	m.removedfee_asset = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, transaction.FieldUUID)
	}
	if m.amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.fee != nil {
		fields = append(fields, transaction.FieldFee)
	}
	if m.precision != nil {
		fields = append(fields, transaction.FieldPrecision)
	}
	if m._type != nil {
		fields = append(fields, transaction.FieldType)
	}
	if m.status != nil {
		fields = append(fields, transaction.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	if m.metadata != nil {
		fields = append(fields, transaction.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldUUID:
		return m.UUID()
	case transaction.FieldAmount:
		return m.Amount()
	case transaction.FieldFee:
		return m.Fee()
	case transaction.FieldPrecision:
		return m.Precision()
	case transaction.FieldType:
		return m.GetType()
	case transaction.FieldStatus:
		return m.Status()
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case transaction.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldUUID:
		return m.OldUUID(ctx)
	case transaction.FieldAmount:
		return m.OldAmount(ctx)
	case transaction.FieldFee:
		return m.OldFee(ctx)
	case transaction.FieldPrecision:
		return m.OldPrecision(ctx)
	case transaction.FieldType:
		return m.OldType(ctx)
	case transaction.FieldStatus:
		return m.OldStatus(ctx)
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transaction.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case transaction.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transaction.FieldFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case transaction.FieldPrecision:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecision(v)
		return nil
	case transaction.FieldType:
		v, ok := value.(transaction.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transaction.FieldStatus:
		v, ok := value.(transaction.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transaction.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.addfee != nil {
		fields = append(fields, transaction.FieldFee)
	}
	if m.addprecision != nil {
		fields = append(fields, transaction.FieldPrecision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmount:
		return m.AddedAmount()
	case transaction.FieldFee:
		return m.AddedFee()
	case transaction.FieldPrecision:
		return m.AddedPrecision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case transaction.FieldFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case transaction.FieldPrecision:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecision(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldUUID:
		m.ResetUUID()
		return nil
	case transaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transaction.FieldFee:
		m.ResetFee()
		return nil
	case transaction.FieldPrecision:
		m.ResetPrecision()
		return nil
	case transaction.FieldType:
		m.ResetType()
		return nil
	case transaction.FieldStatus:
		m.ResetStatus()
		return nil
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transaction.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.portfolio != nil {
		edges = append(edges, transaction.EdgePortfolio)
	}
	if m.account != nil {
		edges = append(edges, transaction.EdgeAccount)
	}
	if m.asset != nil {
		edges = append(edges, transaction.EdgeAsset)
	}
	if m.fee_asset != nil {
		edges = append(edges, transaction.EdgeFeeAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgePortfolio:
		ids := make([]ent.Value, 0, len(m.portfolio))
		for id := range m.portfolio {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeAccount:
		ids := make([]ent.Value, 0, len(m.account))
		for id := range m.account {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeAsset:
		ids := make([]ent.Value, 0, len(m.asset))
		for id := range m.asset {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeFeeAsset:
		ids := make([]ent.Value, 0, len(m.fee_asset))
		for id := range m.fee_asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedportfolio != nil {
		edges = append(edges, transaction.EdgePortfolio)
	}
	if m.removedaccount != nil {
		edges = append(edges, transaction.EdgeAccount)
	}
	if m.removedasset != nil {
		edges = append(edges, transaction.EdgeAsset)
	}
	if m.removedfee_asset != nil {
		edges = append(edges, transaction.EdgeFeeAsset)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgePortfolio:
		ids := make([]ent.Value, 0, len(m.removedportfolio))
		for id := range m.removedportfolio {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeAccount:
		ids := make([]ent.Value, 0, len(m.removedaccount))
		for id := range m.removedaccount {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeAsset:
		ids := make([]ent.Value, 0, len(m.removedasset))
		for id := range m.removedasset {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeFeeAsset:
		ids := make([]ent.Value, 0, len(m.removedfee_asset))
		for id := range m.removedfee_asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedportfolio {
		edges = append(edges, transaction.EdgePortfolio)
	}
	if m.clearedaccount {
		edges = append(edges, transaction.EdgeAccount)
	}
	if m.clearedasset {
		edges = append(edges, transaction.EdgeAsset)
	}
	if m.clearedfee_asset {
		edges = append(edges, transaction.EdgeFeeAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgePortfolio:
		return m.clearedportfolio
	case transaction.EdgeAccount:
		return m.clearedaccount
	case transaction.EdgeAsset:
		return m.clearedasset
	case transaction.EdgeFeeAsset:
		return m.clearedfee_asset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgePortfolio:
		m.ResetPortfolio()
		return nil
	case transaction.EdgeAccount:
		m.ResetAccount()
		return nil
	case transaction.EdgeAsset:
		m.ResetAsset()
		return nil
	case transaction.EdgeFeeAsset:
		m.ResetFeeAsset()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *uuid.UUID
	email             *string
	name              *string
	password          *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	accounts          map[int]struct{}
	removedaccounts   map[int]struct{}
	clearedaccounts   bool
	portfolios        map[int]struct{}
	removedportfolios map[int]struct{}
	clearedportfolios bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *UserMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *UserMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *UserMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *UserMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *UserMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *UserMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *UserMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddPortfolioIDs adds the "portfolios" edge to the Portfolio entity by ids.
func (m *UserMutation) AddPortfolioIDs(ids ...int) {
	if m.portfolios == nil {
		m.portfolios = make(map[int]struct{})
	}
	for i := range ids {
		m.portfolios[ids[i]] = struct{}{}
	}
}

// ClearPortfolios clears the "portfolios" edge to the Portfolio entity.
func (m *UserMutation) ClearPortfolios() {
	m.clearedportfolios = true
}

// PortfoliosCleared reports if the "portfolios" edge to the Portfolio entity was cleared.
func (m *UserMutation) PortfoliosCleared() bool {
	return m.clearedportfolios
}

// RemovePortfolioIDs removes the "portfolios" edge to the Portfolio entity by IDs.
func (m *UserMutation) RemovePortfolioIDs(ids ...int) {
	if m.removedportfolios == nil {
		m.removedportfolios = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.portfolios, ids[i])
		m.removedportfolios[ids[i]] = struct{}{}
	}
}

// RemovedPortfolios returns the removed IDs of the "portfolios" edge to the Portfolio entity.
func (m *UserMutation) RemovedPortfoliosIDs() (ids []int) {
	for id := range m.removedportfolios {
		ids = append(ids, id)
	}
	return
}

// PortfoliosIDs returns the "portfolios" edge IDs in the mutation.
func (m *UserMutation) PortfoliosIDs() (ids []int) {
	for id := range m.portfolios {
		ids = append(ids, id)
	}
	return
}

// ResetPortfolios resets all changes to the "portfolios" edge.
func (m *UserMutation) ResetPortfolios() {
	m.portfolios = nil
	m.clearedportfolios = false
	m.removedportfolios = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUUID:
		return m.UUID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldPassword:
		return m.Password()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.accounts != nil {
		edges = append(edges, user.EdgeAccounts)
	}
	if m.portfolios != nil {
		edges = append(edges, user.EdgePortfolios)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.portfolios))
		for id := range m.portfolios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, user.EdgeAccounts)
	}
	if m.removedportfolios != nil {
		edges = append(edges, user.EdgePortfolios)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.removedportfolios))
		for id := range m.removedportfolios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccounts {
		edges = append(edges, user.EdgeAccounts)
	}
	if m.clearedportfolios {
		edges = append(edges, user.EdgePortfolios)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAccounts:
		return m.clearedaccounts
	case user.EdgePortfolios:
		return m.clearedportfolios
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case user.EdgePortfolios:
		m.ResetPortfolios()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
